[ { "title": "Python Server with basic API", "url": "/posts/service/", "categories": "homelab, software", "tags": "servers, ubuntu, linux, scripting, python", "date": "2025-03-14 21:46:00 -0700", "snippet": "# Setting Up a Python Web Server with API Endpoints on a Homelab ServerThis guide walks you through setting up a simple Python web server using **Flask** on an unused homelab server. The server will have API endpoints to serve basic text data.---## Prerequisites1. **Server Setup**: Ensure your server has a working OS (e.g., Ubuntu Linux or Windows).2. **Python Installed**: Python 3.x is required. Check with: ```bash python3 --versionIf not installed, install it (e.g., on Ubuntu): sudo apt update &amp;&amp; sudo apt install python3 python3-pip Network Access: Confirm the server is on your home network and note its IP address (e.g., 192.168.1.x). Use ifconfig (Linux) or ipconfig (Windows) to find it.Step 1: Set Up Your Environment SSH into the Server (if remote): ssh user@server-ip Replace user and server-ip with your server’s credentials. Create a Project Directory: mkdir my_web_servercd my_web_server Set Up a Virtual Environment (optional but recommended): python3 -m venv venvsource venv/bin/activate # On Windows: venv\\Scripts\\activate Install Flask:With the virtual environment active: pip install flask Step 2: Write a Simple Flask AppCreate a file called app.py in your project directory and add the following code:from flask import Flask, jsonifyapp = Flask(__name__)# Sample text data (you can modify this)text_data = { \"greeting\": \"Hello from your homelab server!\", \"status\": \"Running smoothly\", \"date\": \"March 14, 2025\"}# Root endpoint@app.route('/')def home(): return \"Welcome to my homelab server!\"# API endpoint to get all text data@app.route('/api/text', methods=['GET'])def get_text(): return jsonify(text_data)# API endpoint to get specific text by key@app.route('/api/text/&lt;key&gt;', methods=['GET'])def get_text_by_key(key): return jsonify({key: text_data.get(key, \"Key not found\")})if __name__ == '__main__': app.run(host='0.0.0.0', port=5000, debug=True) Explanation: /: A simple welcome message. /api/text: Returns all text data as JSON. /api/text/&lt;key&gt;: Returns a specific value (e.g., /api/text/greeting returns {\"greeting\": \"Hello from your homelab server!\"}). host='0.0.0.0': Makes the server accessible from other devices on your network. port=5000: The port the server listens on (customizable). Step 3: Run the Server Start the Flask App: python3 app.py Expected output:``` Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)``` Test Locally (on the server):Open a browser or use curl: curl http://localhost:5000/curl http://localhost:5000/api/text Test from Another Device:From another machine on your network, use the server’s IP: http://192.168.1.x:5000/http://192.168.1.x:5000/api/text Replace 192.168.1.x with your server’s actual IP. Step 4: Make It Persistent (Optional)Running python3 app.py manually is fine for testing, but for continuous operation: Use a Process Manager like systemd (Linux): Create a service file: sudo nano /etc/systemd/system/mywebserver.service Add this (adjust paths): [Unit]Description=My Flask Web ServerAfter=network.target[Service]User=your-usernameWorkingDirectory=/home/your-username/my_web_serverExecStart=/home/your-username/my_web_server/venv/bin/python3 app.pyRestart=always[Install]WantedBy=multi-user.target Enable and start it: sudo systemctl enable mywebserversudo systemctl start mywebserver Check Status: sudo systemctl status mywebserver Step 5: Customize and Secure (Optional) Add More Endpoints: Edit app.py to serve different data or add POST endpoints. Firewall: Ensure port 5000 is open: sudo ufw allow 5000 HTTPS: For external access, use a reverse proxy like Nginx with Let’s Encrypt SSL. Debug Mode: Disable debug=True in production for security.Example Usage Visit http://192.168.1.x:5000/api/text: { \"greeting\": \"Hello from your homelab server!\", \"status\": \"Running smoothly\", \"date\": \"March 14, 2025\"} Visit http://192.168.1.x:5000/api/text/status: { \"status\": \"Running smoothly\"} " }, { "title": "Python log folder watcher", "url": "/posts/log-watcher-python/", "categories": "homelab, software", "tags": "servers, ubuntu, linux, scripting, python", "date": "2025-02-22 14:40:00 -0700", "snippet": "This guide provides a complete solution for monitoring log files in a specified directory and sending notifications via ntfy.sh when files are created or modified. It includes a Python script that watches for .log file changes and a systemd service configuration to ensure the monitor runs continuously, restarting automatically on crashes or system reboots. Perfect for system administrators who need real-time alerts about log file activities.# log_monitor.pyimport osimport timefrom watchdog.observers import Observerfrom watchdog.events import FileSystemEventHandlerimport requestsclass LogFileHandler(FileSystemEventHandler): def __init__(self, ntfy_topic): self.ntfy_topic = ntfy_topic self.last_modified = {} def notify(self, filepath): filename = os.path.basename(filepath) message = f\"Log file updated: {filename}\" try: requests.post( f\"https://ntfy.sh/{self.ntfy_topic}\", data=message.encode('utf-8'), headers={ \"Title\": \"Log File Notification\", \"Priority\": \"default\" } ) print(f\"Notification sent for {filename}\") except Exception as e: print(f\"Failed to send notification: {e}\") def on_created(self, event): if event.is_directory: return filepath = event.src_path if filepath.endswith('.log'): self.notify(filepath) self.last_modified[filepath] = os.path.getmtime(filepath) def on_modified(self, event): if event.is_directory: return filepath = event.src_path if filepath.endswith('.log'): current_mtime = os.path.getmtime(filepath) last_mtime = self.last_modified.get(filepath, 0) if current_mtime &gt; last_mtime: self.notify(filepath) self.last_modified[filepath] = current_mtimedef monitor_logs(directory_path, ntfy_topic): if not os.path.exists(directory_path): print(f\"Directory {directory_path} does not exist\") return event_handler = LogFileHandler(ntfy_topic) observer = Observer() observer.schedule(event_handler, directory_path, recursive=False) observer.start() print(f\"Monitoring {directory_path} for .log files...\") try: while True: time.sleep(1) except KeyboardInterrupt: observer.stop() print(\"\\nMonitoring stopped\") observer.join()if __name__ == \"__main__\": WATCH_DIRECTORY = \"/path/to/your/logs\" # Replace with your directory path NTFY_TOPIC = \"your_ntfy_topic\" # Replace with your ntfy.sh topic monitor_logs(WATCH_DIRECTORY, NTFY_TOPIC)Setup Instructions Install dependencies: pip install watchdog requests Save the script as log_monitor.py in /usr/local/bin/ Make it executable: chmod +x /usr/local/bin/log_monitor.py Configure the script: Replace WATCH_DIRECTORY with your directory path Replace NTFY_TOPIC with your ntfy.sh topic Systemd Service Configuration Create service file: sudo nano /etc/systemd/system/log-monitor.service Add this content:```ini[Unit]Description=Log File Monitor ServiceAfter=network.target[Service]Type=simpleExecStart=/usr/bin/python3 /usr/local/bin/log_monitor.pyWorkingDirectory=/usr/local/binRestart=alwaysRestartSec=10User=your_usernameEnvironment=”PYTHONUNBUFFERED=1”[Install]WantedBy=multi-user.target3. Replace:- `your_username` with your actual username- Adjust paths if different## Service Management1. Enable and start:```bashsudo systemctl daemon-reloadsudo systemctl enable log-monitor.servicesudo systemctl start log-monitor.service Useful commands:```bash Check status sudo systemctl status log-monitor.service Stop servicesudo systemctl stop log-monitor.serviceRestart servicesudo systemctl restart log-monitor.serviceView logsjournalctl -u log-monitor.service```Features Monitors .log files in specified directory Sends ntfy.sh notifications on create/modify Runs as a persistent service Auto-restarts on crash or reboot Real-time loggingPrerequisites Python 3 watchdog and requests packages ntfy.sh account/topic Linux system with systemd" }, { "title": "Arch Cheat Sheet", "url": "/posts/arch-cheats/", "categories": "homelab, hardware", "tags": "servers, arch, linux, cheat", "date": "2023-04-28 21:25:00 -0700", "snippet": "Arch install WiFi connection$ iwctl[iwd]# station wlan0 connect SSIDArch install fix keyring$ killall gpg-agent$ rm -rf /etc/pacman.d/gnupg/*$ pacman-key --init$ pacman-key --populate archlinux$ pacman -Sy" }, { "title": "Misc Cheat Sheet", "url": "/posts/Misc-Cheat/", "categories": "homelab, hardware", "tags": "servers, ubuntu, linux, plex, cheat", "date": "2023-04-18 08:30:00 -0700", "snippet": "Git Credentials Management## Windows:git config --global credential.helper wincred## Linux:git config --global credential.helper storeWindows ssh-copy-idtype $env:USERPROFILE\\.ssh\\id_rsa.pub | ssh {IP-ADDRESS-OR-FQDN} \"cat &gt;&gt; .ssh/authorized_keys\"Run script from URLbash &lt;(curl -s http://mywebsite.example/myscript.sh)Fix VM duplicate IP# Must be ran as root!sudo suecho -n &gt;/etc/machine-idrm /var/lib/dbus/machine-idln -s /etc/machine-id /var/lib/dbus/machine-idFix VM “disk not bootable”# Write new tablegdisk /dev/zvol/vm-disk" }, { "title": "Docker Cheat Sheet", "url": "/posts/Docker-Cheat/", "categories": "homelab, hardware", "tags": "servers, ubuntu, linux, docker", "date": "2023-03-31 14:40:00 -0700", "snippet": "Docker Cheat Sheet# update container$ docker-compose pull# Restart container$ docker-compose up -d --remove-orphans# Remove obsolete images$ docker image prune" }, { "title": "Partition Cheat Sheet", "url": "/posts/Drive-Cheat/", "categories": "homelab, hardware", "tags": "servers, ubuntu, linux, plex", "date": "2023-03-27 22:38:00 -0700", "snippet": "Common drive/volume resizeFind drivesudo fdisk -lExtend physical drive partition# \"3\" being the partition numbersudo growpart /dev/sda 3Resize file systemsudo resize2fs /dev/sda3Common drive commandsdf -hdu -sh# if installedsudo ncdu /" }, { "title": "Tarball Cheat Sheet", "url": "/posts/Tar-Cheat/", "categories": "homelab, hardware", "tags": "servers, ubuntu, linux, plex", "date": "2023-03-27 22:30:00 -0700", "snippet": "Tar.gz FilesList contentstar -tvf archive.tar.gzCompress Tar.gz# -args output filename/directory to tartar -cvzf archive filenameExtract tar.gz# -C flag to specify output tar -xvf archive.tar.gz -C /home/linuxize/files" }, { "title": "Drive Mount Cheat Sheet", "url": "/posts/Mount-Cheat/", "categories": "homelab, hardware", "tags": "servers, dell, supermicro", "date": "2023-03-27 19:43:00 -0700", "snippet": "Network Sharesudo apt updatesudo apt install cifs-utilssudo mkdir /mnt/win_shareSetup credentials file usually in root directoryusername=userpassword=passworddomain=domainMay need to adjust permissionssudo chmod 600 /etc/win-credentialsMount sharesudo mount -t cifs -o credentials=/etc/win-credentials //WIN_SHARE_IP/&lt;share_name&gt; /mnt/win_shareAuto mount at bootsudo nano /etc/fstab# &lt;file system&gt; &lt;dir&gt; &lt;type&gt; &lt;options&gt; &lt;dump&gt; &lt;pass&gt;//WIN_SHARE_IP/share_name /mnt/win_share cifs credentials=/etc/win-credentials,file_mode=0755,dir_mode=0755 0 0# Mount all fstab mountsmount -a" }, { "title": "Hey Baby", "url": "/posts/hibabe/", "categories": "family", "tags": "fun, fam", "date": "2022-08-08 11:32:00 -0700", "snippet": "WelcomeWell, Hello beautiful.ToDo: Hug and Kiss my wife :) Maybe add the ability to comment on posts???" }, { "title": "Hello World", "url": "/posts/hello/", "categories": "homelab, hardware", "tags": "servers, dell, supermicro", "date": "2022-08-08 11:13:00 -0700", "snippet": "WelcomeHello Yall.ToDo: setup pingdef ping(host): param = '-n' if platform.system().lower()=='windows' else '-c' command = ['ping', param, '1', host] try: response = subprocess.call(command, stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT) except Exception: print('Something went wrong!') return False if response == 0: #print('{} is Online'.format(host)) return True else: #print('{} is Offline'.format(host)) return False" } ]
